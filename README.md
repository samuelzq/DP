<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

# 动态规划算法例题集

**动态规划「Dynamic programming」**

**DP**

![DP](https://tse2-mm.cn.bing.net/th/id/OIP.9E03l6gZjqN3feiCvJaaUwHaF7?w=171&h=160&c=7&o=5&pid=1.7 "DP")

解决问题最强大的技术之一是将问题分解为较小，较容易解决的部分。 较小的问题不那么
令人费解，它们使我们可以更专注于研究整个问题的细节。动态规划算法的核心是分而治之。
该方法通常从问题中删除一个元素，以形成待解决的较小问题。待该较小问题的解决方案后，
再以正确的方式添加回被删除的元素。

## 动态规划的特征
**<font size=4>最优化</font>**

无论过去的状态和决策如何，余下的决策必须构成最优策略。简单来说就是一个最优化
策略的子策略总是最优的。

**<font size=4>无后效性</font>**

收益只与当前状态和决策相关，与达到该状态的方式无关。

**<font size=4>子问题的重叠性</font>**

避免冗余、重复计算，将数级的暴力搜索算法改进到了具有多项式时间复杂度的算法。

## 动态规划的关键点
* **<font size=4>最优子结构</font>**

* **<font size=4>边界</font>**

* **<font size=4>状态转移公式</font>**

## 线性DP

决定线性DP状态的约束条件是线性的。

### 典型的线性DP问题：

1.  爬楼梯
2.  数字金字塔
3.  最长上升子序列（LIS）
4.  最长公共子序列（LCS）

## 区间DP

区间DP将待解决问题划分为不同的阶段。首先在较小的区间上获得最优解，然后再将小区间
合并求得最终解。

**实现思路**

假设状态转移数组为dp[n][m]，dp[i][j]表示从状态i到状态j的最优解。

```
    for (int i = 1; i <= n; i++)
        dp[i][i]=初始值

    for (int len = 2; len <= n; len++) {  //区间长度
        for(int i = 1; i <= n; i++)  {       //枚举起点
            int j = i + len - 1;           //区间终点
            if (j > n)
                break;           //越界结束
            for (int k = i; k < j; k++)   //枚举分割点，构造状态转移方程
                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + w[i][j]);
        }
    }
```

### 典型区间DP问题：

1. 石子合并
2. 括号匹配
3. 整数划分
4. 凸多边形三角划分
5. 背包

## 例题集


### 爬楼梯

有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法。

#### 分析

我们仔细考察每一级台阶，发现：$n = 1$ 时，只有一种选择；$n = 2$ 时，有两种选择。
当 $n > 2$ 时候，必然是从 $n - 1$ 级台阶迈一步或者是从 $n - 2$ 级台阶迈两步。

我们让 $f(n)$ 表示走上 $n$ 级台阶的方法数。

**【最优子结构】**

$f(n-1)$ 和 $f(n-2)$

**【边界】**

$f(1)$ 和 $f(2)$

**【状态转移公式】**

$$
f(n)=\begin{cases}
1,\quad &n=1 \\
2, \quad &n=2 \\
f(n-1)+f(n-2),\quad &n>0
\end{cases}
$$

**【时间复杂度】**

如果使用递归算法，$dp[k]\;(k \le (n-2))$ 将会被计算 $ 2^{n-k-1} $ 次。这样整个算
法的复杂度将为 $O(2^n)$ 。因此可以将计算过的结果缓存下来，这样时间复杂度将降为
$O(n)$ 。

### 最长递增子序列(LIS)

一个序列 $A$，当 $a_1 \lt a_2 \lt … \lt a_s$ 的时候，我们称这个序列是上升的。
对于给定的一个序列 $(a_1,\;a_2,\;...,\;a_n)$，我们可以得到一些上升的子序列
$(a_{i_1},\; a_{i_2},\; …,\; a_{i_k})$ ，这里 $ 1 \le i_1 \lt i_2 \lt … \lt i_k \le n $ 。

#### 分析
##### 解法一
**【最优子结构】**

$dp[i]$ 代表以 $a[i]$ 结尾的LIS的长度。

**【边界】**

$dp[i]=1$

**【状态转移公式】**

$dp[i]=max(dp[i],\; dp[j]+1)\quad (0<=j< i,\; a[j]< a[i])$

**【时间复杂度】**

由于需要将每一个子区间内最后一个元素与其前面的元素比较，因此本算法时间复杂度
$ O(n^2) $。

##### 解法二

这种解法利用了**贪心算法+二分查找**。对于一个上升子序列，显然当前最后一个元素越
小，越有利于添加新的元素，这样LIS长度自然会更长。

按照以下规则将 $ a[i] $ 添加到 $ dp[] $ 数组中：
```
    if (a[i] > dp[k - 1]  // dp 当前长度k
        dp[k] = a[i];
    else
        // 用a[i]替换dp[ ]中第一个比它大的元素
```

**【时间复杂度】**

由于使用二分法查找，此种算法的时间复杂度为 $O(nlog(n))$ 。