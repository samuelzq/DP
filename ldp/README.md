<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

# 线性规划例题集

**收录典型的线性规划问题**

## 爬楼梯

有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法。

### 分析

我们仔细考察每一级台阶，发现：$n = 1$ 时，只有一种选择；$n = 2$ 时，有两种选择。
当 $n > 2$ 时候，必然是从 $n - 1$ 级台阶迈一步或者是从 $n - 2$ 级台阶迈两步。

我们让 $f(n)$ 表示走上 $n$ 级台阶的方法数。

**【最优子结构】**

$f(n-1)$ 和 $f(n-2)$

**【边界】**

$f(1)$ 和 $f(2)$

**【状态转移公式】**

$$
f(n)=\begin{cases}
1,\quad &n=1 \\
2, \quad &n=2 \\
f(n-1)+f(n-2),\quad &n>0
\end{cases}
$$

**【时间复杂度】**

如果使用递归算法，$dp[k]\;(k \le (n-2))$ 将会被计算 $ 2^{n-k-1} $ 次。这样整个算
法的复杂度将为 $O(2^n)$ 。因此可以将计算过的结果缓存下来，这样时间复杂度将降为
$O(n)$ 。

## 最长递增子序列(LIS)

一个序列 $A$，当 $a_1 \lt a_2 \lt … \lt a_s$ 的时候，我们称这个序列是上升的。
对于给定的一个序列 $(a_1,\;a_2,\;...,\;a_n)$，我们可以得到一些上升的子序列
$(a_{i_1},\; a_{i_2},\; …,\; a_{i_k})$ ，这里 $ 1 \le i_1 \lt i_2 \lt … \lt i_k \le n $ 。

### 分析

#### 解法一
**【最优子结构】**

$dp[i]$ 代表以 $a[i]$ 结尾的LIS的长度。

**【边界】**

$dp[i]=1$

**【状态转移公式】**

$dp[i]=max(dp[i],\; dp[j]+1)\quad (0<=j< i,\; a[j]< a[i])$

**【时间复杂度】**

由于需要将每一个子区间内最后一个元素与其前面的元素比较，因此本算法时间复杂度
$ O(n^2) $。

#### 解法二

这种解法利用了**贪心算法+二分查找**。对于一个上升子序列，显然当前最后一个元素越
小，越有利于添加新的元素，这样LIS长度自然会更长。

按照以下规则将 $ a[i] $ 添加到 $ dp[] $ 数组中：
```
    if (a[i] > dp[k - 1]  // dp 当前长度k
        dp[k] = a[i];
    else
        // 用a[i]替换dp[ ]中第一个比它大的元素
```

**【时间复杂度】**

由于使用二分法查找，此种算法的时间复杂度为 $O(nlog(n))$ 。


#### 解法三

类似于**解法一**：对于 $a[i]$，求得到其在 $A$ 之前的LIS长度。

此处使用树状数组加速查找。首先将 $A$ 按照升序重排（各元素同时要记录下原始的序号）。
然后根据新序列中的次序，依次按各元素原始序号，将其LIS值添加入树状数组。

**【时间复杂度】**

本算法时间复杂度由树状数组的查找和更新来决定，为 $O(nlog(n))$ 。

## 最长公共子序列（LCS）

给定两个长度分别为 **N**、**M** 的字符串 **A** 和 **B**，求最长的既是 **A** 的子
序列又是 **B** 的子序列的字符串的长度。

***
**一个给定的序列的子序列，是将给定序列中零个或多个元素去掉之后得到的结果。**
***

如给定的字符序列：{a、b、c、d、e、f、g、h}，它的子序列有：
1. {a、c、e、f} （{a、~~b~~、c、~~d~~、e、f、~~g~~、~~h~~}）
2. {a、h}
3. {c、d、e}

### 分析

设 $A=\{a_0,\;a_1,\;…,\;a_m\}$，$B=\{b_0,\;b_1,\;…,\;b_n\}$，
$Z=\{z_0,\;z_1,\;…,\;z_k\}$ 为它们的最长公共子序列。

可得以下三种情况：

1. 如果 $a_m = b_n$ ，则 $z_k = a_m = b_n$，且
$\{z_0,\;z_1,\;…,\;z_{k-1}\}$ 是 $\{a_0,\;a_1,\;…,\;a_{m-1}\}$
和 $\{b_0,\;b_1,\;…,\;b_{n-1}\}$ 的一个最长公共子序列；

2. 如果 $a_m != b_n$ ，$z_k != a_m$，则 $\{z_0,\;z_1,\;…,\;z_{k}\}$ 是
$\{a_0,\;a_1,\;…,\;a_{m-1}\}$ 和 $\{b_0,\;b_1,\;…,\;b_n\}$ 的一个
最长公共子序列；

3. 如果 $a_m != b_n$ ，$z_k != b_n$，则 $\{z_0,\;z_1,\;…,\;z_{k}\}$ 是
$\{a_0,\;a_1,\;…,\;a_m\}$ 和 $\{b_0,\;b_1,\;…,\;b_{n-1}\}$ 的一个
最长公共子序列；

**【最优子结构】**

$dp[i][j]$ 表示 $A$ 的前 $i$ 个字符与 $B$ 的前 $j$ 个字符中的最长公共子序列长度。

**【边界】**

$dp[i][0]=dp[0][j]=0$

**【状态转移公式】**

$$
dp[i,\;j]=\begin{cases}
0,\quad &i=0 \lor j=0 \\
dp[i-1,\;j-1]+1, \quad &i,\;j>0,\;A[i]=B[j] \\
max\{dp[i,\;j-1],\;dp[i-1,\;j]\},\quad &i,\;j>0,\;A[i]\neq B[j]
\end{cases}
$$

**【时间复杂度】**

$\Theta(mn)$

## 数字金字塔

从三角形的顶至底的一条路径，使该路径经过的数字总和最大。

	        7
	      3   8
        8   1   0
	  2   7   4   4
	4   5   2   6   5

### 分析

金字塔上，外侧的结点只有一个父节点（只能够从左上方或右上方到达），内部的结点有两
个父节点（可以从左上方或右上方到达）。因此，只需要保证父节点处的数字和最大即可。

我们可以使用矩阵的左下部分来表示数字金字塔。状态转移也可以使用类似的矩阵记录。
状态转移矩阵初始化完成后，在最后一行找出最大值即为本题的解。

**【最优子结构】**

$dp[i][i]$

**【边界】**

$ \qquad\qquad\qquad dp[0][0] = root\_node $

**【状态转移公式】**

$$
dp[i,\;j]=\begin{cases}
\sum_1^iw[k][0],\quad &j=0 \\
\sum_1^iw[k][k], \quad &i=j \\
max\{dp[i,\;j-1],\;dp[i-1,\;j]\}+1,\quad &i>j \land j \neq 0
\end{cases}
$$

**【时间复杂度】**

$O(n^2)$

## 合唱队

$n$ 位同学站成一排，音乐老师要请其中的 $n-k$ 位同学出列，使得剩下的 $k$ 位同学不
交换位置就能排成合唱队形。

**合唱队形定义：** 设 $k$ 位同学从左到右依次编号为 $ 1,\;2,\;…,\;k $ 他们的身高
分别为 $ T_1,\;T_2,\;…,\;T_K $ ，则他们的身高满足
$ T_1<T_2<…<T_i-1<T_i>T_i+1>…>T_K (1<=i<= K) $ 。

**要求：**
已知所有同学的身高，计算最少需要几位同学出列，可使剩余同学排成合唱队形

### 分析

观察合唱队队形，队列两侧和最高的同学之间是两个上升队列。因此本题实质上是LIS问题。
这样，先求得每个位置上正反两个方向的LIS值，两值之和最大的位置就是队列中的制高点。
因此，最终的解为：

$ \qquad\qquad\qquad k = n - (lis_l + lis_r - 1) $