<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

# 区间规划

有一类问题可通过分阶段地划分问题来解决，我们称之为区间模型。

**区间DP**的关键是确定阶段中元素出现的顺序，并选择最佳的区间划分。

令 $dp[i,\;j]$ 表示状态 $i$ 到 $j$ 的最优解。$k$ 表示 $i$ 到 $j$ 的中间状态，则
 $dp[i,\;j]$ 等于 $dp[i,\;k]、dp[k,\;j]$ 以及将两者合并的值 （ $cost$ ）。

  $dp[i,\;j]=dp[i,\;k]+dp[k,\;j]+cost$

## 伪代码

区间DP最简单形式的伪代码(具体要根据题目修改)

	初始化DP数组
	zero(dp)
    for (int i = 1; i <= n; i++)
        dp[i][i]=初始值

    for (int len = 2; len <= n; len++)  //区间长度
        for(int i = 1; i <= n; i++)     //枚举起点
            int j = i + len - 1;        //区间终点
            if (j > n) break;       //越界结束
            for (int k = i; k < j; k++) //枚举分割点，构造状态转移方程
                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + w[i][j]);

## 消除回文

我们有一个连续的序列，每个序列上面都是一个数字 $c[i]$，，消灭之后左右会合并，成
为一个新序列，问最少需要多少次才能够把整个序列消灭掉。

**回文指从左到右或从右到左读到的序列都是相同。**

### 分析

$[i,\;j]$ 之间的数字序列会有三种情况：
1. 只有一个元素（ $i=j$ ），仅需删除一次
2. $i$ 最后删除；$[i+1、\;j]$ 之间的数字序列删除次数增加1次；
3. $[i,\;j]$ 之间的 $k$ 与 $i$ 相同，解为 区间 $[i+1,\;k-1]$ 和  $[k+1,\;j-1]$
的删除次数之和。

**【最优子结构】**

$dp[i][j]$ 区间 $[i,\;j]$ 的删除次数。

**【边界】**

$$
dp[i][i] = 1 \\
dp[i][j] = j - i + 1
$$

**【状态转移公式】**

$$
dp[i][j]=\left\{\begin{array}{ll}
    0,\quad &i>j\\
    1, \quad &i=j\\
    min&\left\{
    \begin{array}{ll}
       dp[i][j]\\
       1+dp[i+1][j]\\
	   2+dp[i+1][j]\\
	   min(dp[i+i][k-1]+dp[k+1][j-1]),\quad i<k<j
	\end{array}
	\right.
\end{array}
\right.
$$

**【时间复杂度】**

$ O(n^3) $

## 括号匹配问题

给出一个的只有‘(’， ‘)’，‘[’，‘]’四种括号组成的字符串，求最多有多少个括号满足题目
里所描述的完全匹配。

### 分析

从长度为 $ 2 $ 的区间开始枚举，最终得到最优解。

**【最优子结构】**

$dp[i][j]$ 区间 $[i,\;j]$ 内的匹配括弧数。

**【边界】**

$dp[i][j] = 0$

**【状态转移公式】**

$ dp[i,\;j]=max(dp[i,\;k]+dp[k,\;j]),\quad i<k<j $.

**【时间复杂度】**

$ O(n^3) $

## 括号添加问题

给你一个字符串，里面只包含 “(”，“)”，“[”，“]” 四种符号，请问你需要至少添加多少个
括号才能使这些括号匹配起来。

如：
1. [] 是匹配的
2. ([])[] 是匹配的
3. ((] 是不匹配的
4. ([)] 是不匹配的

### 分析

本题实质上就是括号匹配。找找到最大的匹配数，剩余的则是需要添加匹配的数目。

## 整数划分

给出两个整数 $n,\; m$ ，要求在 $n$ 中加入 $m - 1$ 个乘号，将 $n$ 分成 $m$ 段，求
出这 $m$ 段的最大乘积。

### 分析

$i$ 个数字间插入 $j$ 个乘号，需先在 $i$ 个数字间先插入 $j-1$ 个乘号，然后在区间
$[i,\;j]$ 间找出最佳分段点 $k$ 。

**【最优子结构】**

$dp[i][j]$ $i$ 个数字间插入 $j$ 个乘号后的乘积。

**【边界】**

$dp[i][0]$ 高 $i$ 位的数值。

**【状态转移公式】**

$ dp[i][j]=max(dp[i,][j],\;dp[k][j-1]*num[k+1][i]) $ ，$num[i][j]$ 表示
$[i,\;j]$ 间的数值。

**【时间复杂度】**

$ O(n^3) $

## 凸多边形三角划分

给定一个具有 $n\;(n <= 50)$ 个顶点(从 $ 1 $ 到 $n$ 编号)的凸多边形，每个顶点的权
值已知。问如何把这个凸多边形划分成 $n - 2 $ 个互不相交的三角形，使得这些三角形顶
点权值的乘积之和最小。

### 分析

可以将区间 $[i,\;j]$ 划分成两段。点 $ k\;(i<k<j) $ ，为分割点。将两子区间的乘积
与 $i,\;k,\;j$ 乘积相加即为最终值。

**【最优子结构】**

$dp[i][j]$ 为从 $i$ 到 $j$ 划分出的三角形的最大乘积。

**【边界】**

$ dp[i][j] = MAX\_INF $

**【状态转移公式】**

$ dp[i][j]=min(dp[i,][j],\;dp[i][k]+dp[k][j]+v[i]*v[k]*v[j]) $

**【时间复杂度】**

$ O(n^3) $